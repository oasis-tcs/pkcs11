## Message-based encryption functions

Message-based encryption refers to the process of encrypting multiple messages
using the same encryption mechanism and encryption key. The encryption mechanism
can be either an authenticated encryption with associated data (AEAD) algorithm
or a pure encryption algorithm.  Cryptoki provides the following functions for
message-based encryption:

### C_MessageEncryptInit

~~~{.c}
CK_DECLARE_FUNCTION(CK_RV, C_MessageEncryptInit)(
    CK_SESSION_HANDLE hSession,
    CK_MECHANISM_PTR pMechanism,
    CK_OBJECT_HANDLE hKey
);
~~~

**C_MessageEncryptInit** prepares a session for one or more encryption
operations that use the same encryption mechanism and encryption key. _hSession_
is the session’s handle; _pMechanism_ points to the encryption mechanism; _hKey_
is the handle of the encryption key.

The **CKA_ENCRYPT** attribute of the encryption key, which indicates whether the
key supports encryption, MUST be CK_TRUE.

After calling **C_MessageEncryptInit**, the application can either call
**C_EncryptMessage** to encrypt a message in a single part, or call
**C_EncryptMessageBegin**, followed by **C_EncryptMessageNext** one or more
times, to encrypt a message in multiple parts. This may be repeated several
times. The message-based encryption process is active until the application
calls **C_MessageEncryptFinal** to finish the message-based encryption process.

**C_MessageEncryptInit** can be called with _pMechanism_ set to NULL_PTR to
terminate a message-based encryption process. If a multi-part message encryption
operation is active, it will also be terminated. If an active operation has been
initialized and it cannot be cancelled, CKR_OPERATION_CANCEL_FAILED must be
returned.

Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR,
CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED,
CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY,
CKR_KEY_FUNCTION_NOT_PERMITTED, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE,
CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID,
CKR_OK, CKR_OPERATION_ACTIVE, CKR_PENDING, CKR_PIN_EXPIRED, CKR_SESSION_CLOSED,
CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN, CKR_OPERATION_CANCEL_FAILED.

### C_EncryptMessage

~~~{.c}
CK_DECLARE_FUNCTION(CK_RV, C_EncryptMessage)(
    CK_SESSION_HANDLE hSession,
    CK_VOID_PTR pParameter,
    CK_ULONG ulParameterLen,
    CK_BYTE_PTR pAssociatedData,
    CK_ULONG ulAssociatedDataLen,
    CK_BYTE_PTR pPlaintext,
    CK_ULONG ulPlaintextLen,
    CK_BYTE_PTR pCiphertext,
    CK_ULONG_PTR pulCiphertextLen
);
~~~

**C_EncryptMessage** encrypts a message in a single part. _hSession_ is the
session’s handle; _pParameter_ and _ulParameterLen_ specify any
mechanism-specific parameters for the message encryption operation;
_pAssociatedData_ and _ulAssociatedDataLen_ specify the associated data for an
AEAD mechanism; _pPlaintext_ points to the plaintext data; _ulPlaintextLen_ is
the length in bytes of the plaintext data; _pCiphertext_ points to the location
that receives the encrypted data; _pulCiphertextLen_ points to the location that
holds the length in bytes of the encrypted data.

Typically, _pParameter_ is an initialization vector (IV) or nonce. Depending on
the mechanism parameter passed to **C_MessageEncryptInit**, _pParameter_ may be
either an input or an output parameter. For example, if the mechanism parameter
specifies an IV generator mechanism, the IV generated by the IV generator will
be output to the _pParameter_ buffer.

If the encryption mechanism is not AEAD, _pAssociatedData_ and
_ulAssociatedDataLen_ are not used and should be set to (NULL, 0).

**C_EncryptMessage** uses the convention described in Section 5.2 on producing
output.

The message-based encryption process MUST have been initialized with
**C_MessageEncryptInit**. A call to **C_EncryptMessage** begins and terminates a
message encryption operation.

**C_EncryptMessage** cannot be called in the middle of a multi-part message
encryption operation.

For some encryption mechanisms, the input plaintext data has certain length
constraints (either because the mechanism can only encrypt relatively short
pieces of plaintext, or because the mechanism’s input data MUST consist of an
integral number of blocks). If these constraints are not satisfied, then
**C_EncryptMessage** will fail with return code **CKR_DATA_LEN_RANGE**. The
plaintext and ciphertext can be in the same place, i.e., it is OK if
_pPlaintext_ and _pCiphertext_ point to the same location.

For most mechanisms, **C_EncryptMessage** is equivalent to
**C_EncryptMessageBegin** followed by a sequence of **C_EncryptMessageNext**
operations.

Return values: CKR_ARGUMENTS_BAD, CKR_BUFFER_TOO_SMALL,
CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_INVALID, CKR_DATA_LEN_RANGE,
CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED,
CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY,
CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE,
CKR_OPERATION_NOT_INITIALIZED, CKR_PENDING, CKR_SESSION_CLOSED,
CKR_SESSION_HANDLE_INVALID.

### C_EncryptMessageBegin

~~~{.c}
CK_DECLARE_FUNCTION(CK_RV, C_EncryptMessageBegin)(  
    CK_SESSION_HANDLE hSession,
    CK_VOID_PTR pParameter,
    CK_ULONG ulParameterLen,
    CK_BYTE_PTR pAssociatedData,
    CK_ULONG ulAssociatedDataLen
);
~~~

**C_EncryptMessageBegin** begins a multiple-part message encryption operation.
_hSession_ is the session’s handle; _pParameter_ and _ulParameterLen_ specify
any mechanism-specific parameters for the message encryption operation;
_pAssociatedData_ and _ulAssociatedDataLen_ specify the associated data for an
AEAD mechanism.

Typically, _pParameter_ is an initialization vector (IV) or nonce. Depending on
the mechanism parameter passed to **C_MessageEncryptInit**, _pParameter_ may be
either an input or an output parameter. For example, if the mechanism parameter
specifies an IV generator mechanism, the IV generated by the IV generator will
be output to the _pParameter_ buffer.

If the mechanism is not AEAD, _pAssociatedData_ and _ulAssociatedDataLen_ are
not used and should be set to (NULL, 0).

After calling **C_EncryptMessageBegin**, the application should call
**C_EncryptMessageNext** one or more times to encrypt the message in multiple
parts. The message encryption operation is active until the application uses a
call to **C_EncryptMessageNext** with flags=**CKF_END_OF_MESSAGE** to actually
obtain the final piece of ciphertext. To process additional messages (in single
or multiple parts), the application MUST call **C_EncryptMessage** or
**C_EncryptMessageBegin** again.

Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR,
CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED,
CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY,
CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE,
CKR_OPERATION_NOT_INITIALIZED, CKR_PENDING, CKR_PIN_EXPIRED, CKR_SESSION_CLOSED,
CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.

### C_EncryptMessageNext

~~~{.c}
CK_DECLARE_FUNCTION(CK_RV, C_EncryptMessageNext)(  
    CK_SESSION_HANDLE hSession,
    CK_VOID_PTR pParameter,
    CK_ULONG ulParameterLen,
    CK_BYTE_PTR pPlaintextPart,
    CK_ULONG ulPlaintextPartLen,
    CK_BYTE_PTR pCiphertextPart,
    CK_ULONG_PTR pulCiphertextPartLen,
    CK_FLAGS flags
);
~~~

**C_EncryptMessageNext** continues a multiple-part message encryption operation,
processing another message part. _hSession_ is the session’s handle;
_pParameter_ and _ulParameterLen_ specify any mechanism-specific parameters for
the message encryption operation; _pPlaintextPart_ points to the plaintext
message part; _ulPlaintextPartLen_ is the length of the plaintext message part;
_pCiphertextPart_ points to the location that receives the encrypted message
part; _pulCiphertextPartLen_ points to the location that holds the length in
bytes of the encrypted message part; _flags_ is set to 0 if there is more
plaintext data to follow, or set to **CKF_END_OF_MESSAGE** if this is the last
plaintext part.

Typically, _pParameter_ is an initialization vector (IV) or nonce. Depending on
the mechanism parameter passed to **C_EncryptMessageNext**, _pParameter_ may be
either an input or an output parameter. For example, if the mechanism parameter
specifies an IV generator mechanism, the IV generated by the IV generator will
be output to the _pParameter_ buffer.

**C_EncryptMessageNext** uses the convention described in Section 5.2 on
producing output.

The message encryption operation MUST have been started with
**C_EncryptMessageBegin**. This function may be called any number of times in
succession. A call to **C_EncryptMessageNext** with flags=0 which results in an
error other than CKR_BUFFER_TOO_SMALL terminates the current message encryption
operation. A call to **C_EncryptMessageNext** with flags=**CKF_END_OF_MESSAGE**
always terminates the active message encryption operation unless it returns
**CKR_BUFFER_TOO_SMALL** or is a successful call (i.e., one which returns
**CKR_OK**) to determine the length of the buffer needed to hold the ciphertext.

Although the last **C_EncryptMessageNext** call ends the encryption of a
message, it does not finish the message-based encryption process. Additional
**C_EncryptMessage** or **C_EncryptMessageBegin** and **C_EncryptMessageNext**
calls may be made on the session.

The plaintext and ciphertext can be in the same place, i.e., it is OK if
_pPlaintextPart_ and _pCiphertextPart_ point to the same location.

For some multi-part encryption mechanisms, the input plaintext data has certain
length constraints, because the mechanism’s input data MUST consist of an
integral number of blocks. If these constraints are not satisfied when the final
message part is supplied (i.e., with flags=**CKF_END_OF_MESSAGE**), then
**C_EncryptMessageNext** will fail with return code **CKR_DATA_LEN_RANGE**.

Return values: CKR_ARGUMENTS_BAD, CKR_BUFFER_TOO_SMALL,
CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR,
CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED,
CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY,
CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE,
CKR_OPERATION_NOT_INITIALIZED, CKR_PENDING, CKR_SESSION_CLOSED,
CKR_SESSION_HANDLE_INVALID.

### C_MessageEncryptFinal

~~~{.c}
CK_DECLARE_FUNCTION(CK_RV, C_MessageEncryptFinal)(  
    CK_SESSION_HANDLE hSession
);
~~~

**C_MessageEncryptFinal** finishes a message-based encryption process.
_hSession_ is the session’s handle.

The message-based encryption process MUST have been initialized with
**C_MessageEncryptInit**.

Return values: CKR_ARGUMENTS_BAD, CKR_CRYPTOKI_NOT_INITIALIZED,
CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED,
CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK,
CKR_OPERATION_ACTIVE, CKR_OPERATION_NOT_INITIALIZED, CKR_PENDING,
CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.

Example:

~~~{.c}
#define PLAINTEXT_BUF_SZ 200
#define AUTH_BUF_SZ 100
#define CIPHERTEXT_BUF_SZ 256

CK_SESSION_HANDLE hSession;
CK_OBJECT_HANDLE hKey;
CK_BYTE iv[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
CK_BYTE tag[16];
CK_GCM_MESSAGE_PARAMS gcmParams = {
  iv,
  sizeof(iv) * 8,
  0,
  CKG_NO_GENERATE,
  tag,
  sizeof(tag) * 8
};
CK_MECHANISM mechanism = {
  CKM_AES_GCM, &gcmParams, sizeof(gcmParams)
};
CK_BYTE data[2][PLAINTEXT_BUF_SZ];
CK_BYTE auth[2][AUTH_BUF_SZ];
CK_BYTE encryptedData[2][CIPHERTEXT_BUF_SZ];
CK_ULONG ulEncryptedDataLen, ulFirstEncryptedDataLen;
CK_ULONG firstPieceLen = PLAINTEXT_BUF_SZ / 2;

/* error handling is omitted for better readability */
.
.
C_MessageEncryptInit(hSession, &mechanism, hKey);
/* encrypt message en bloc with given IV */
ulEncryptedDataLen = sizeof(encryptedData[0]);
C_EncryptMessage(hSession,
  &gcmParams, sizeof(gcmParams),
  &auth[0][0], sizeof(auth[0]),
  &data[0][0], sizeof(data[0]),
  &encryptedData[0][0], &ulEncryptedDataLen);
/* iv and tag are set now for message */

/* encrypt message in two steps with generated IV */
gcmParams.ivGenerator = CKG_GENERATE;
C_EncryptMessageBegin(hSession,
  &gcmParams, sizeof(gcmParams),
  &auth[1][0], sizeof(auth[1])
);
/* encrypt first piece */
ulFirstEncryptedDataLen = sizeof(encryptedData[1]);
C_EncryptMessageNext(hSession,
  &gcmParams, sizeof(gcmParams),
  &data[1][0], firstPieceLen,
  &encryptedData[1][0], &ulFirstEncryptedDataLen,
  0
);
/* encrypt second piece */
ulEncryptedDataLen = sizeof(encryptedData[1]) - ulFirstEncryptedDataLen;
C_EncryptMessageNext(hSession,
  &gcmParams, sizeof(gcmParams),
  &data[1][firstPieceLen], sizeof(data[1])-firstPieceLen,
  &encryptedData[1][ulFirstEncryptedDataLen], &ulEncryptedDataLen,
  CKF_END_OF_MESSAGE
);
/* tag is set now for message */

/* finalize */
C_MessageEncryptFinal(hSession);
~~~
